#ifndef _FTL_MUON_ISOLATION_
#define _FTL_MUON_ISOLATION_

// system include files
#include <cmath>
#include <cstdlib>
#include <memory>
#include <unordered_map>

// user include files
#include "FWCore/Framework/interface/Frameworkfwd.h"
#include "FWCore/Framework/interface/EDAnalyzer.h"

#include "FWCore/Framework/interface/Event.h"
#include "FWCore/Framework/interface/MakerMacros.h"

#include "FWCore/ParameterSet/interface/ParameterSet.h"

#include "FWCore/Framework/interface/ConsumesCollector.h"
#include "FWCore/Framework/interface/EDConsumerBase.h"

#include "DataFormats/MuonReco/interface/Muon.h"
#include "DataFormats/MuonReco/interface/MuonFwd.h"

#include "DataFormats/ParticleFlowReco/interface/PFClusterFwd.h"
#include "DataFormats/ParticleFlowReco/interface/PFCluster.h"

#include "SimDataFormats/Vertex/interface/SimVertex.h"
#include "DataFormats/VertexReco/interface/Vertex.h"
#include "DataFormats/VertexReco/interface/VertexFwd.h"
#include "TrackingTools/TransientTrack/interface/TransientTrackBuilder.h"
#include "TrackingTools/Records/interface/TransientTrackRecord.h"
#include "TrackingTools/IPTools/interface/IPTools.h"

#include "DataFormats/JetReco/interface/GenJetCollection.h"

#include "FWCore/ServiceRegistry/interface/Service.h"
#include "CommonTools/UtilAlgos/interface/TFileService.h"

#include "DataFormats/Math/interface/deltaR.h"

#include "DataFormats/HepMCCandidate/interface/GenParticle.h"
#include "DataFormats/HepMCCandidate/interface/GenParticleFwd.h"

#include "DataFormats/MuonReco/interface/MuonSelectors.h"

#include "TTree.h"
#include "TRandom.h"

#include "PrecisionTiming/FTLAnalysis/interface/FTLMuonIsoTree.h"

//
// class declaration
//
class FTLMuonIsolation : public edm::EDAnalyzer{
public:

  typedef edm::Association<reco::VertexCollection> CandToVertex;
  typedef edm::ValueMap<int> CandToVertexQuality;
  typedef ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>, ROOT::Math::DefaultCoordinateSystemTag> genXYZ;
  typedef ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>, ROOT::Math::DefaultCoordinateSystemTag> Point;

  explicit FTLMuonIsolation(const edm::ParameterSet&);
  ~FTLMuonIsolation() {};

  static void fillDescriptions(edm::ConfigurationDescriptions& descriptions);


private:
  virtual void beginJob() override {};
  virtual void analyze(const edm::Event&, const edm::EventSetup&) override;
  virtual void endJob() override {};

  //---member data
  edm::EDGetTokenT<genXYZ>                            genXYZToken_;
  edm::Handle<genXYZ>                                 genXYZHandle_;
  edm::EDGetTokenT<float>                             genT0Token_;
  edm::Handle<float>                                  genT0Handle_;
  edm::EDGetTokenT<vector<SimVertex> >                simVtxToken_;
  edm::Handle<vector<SimVertex> >                     simVtxHandle_;
  edm::EDGetTokenT<reco::VertexCollection>            vtx3DToken_;
  edm::Handle<reco::VertexCollection>                 vtx3DHandle_;
  edm::EDGetTokenT<reco::VertexCollection>            vtx4DToken_;
  edm::Handle<reco::VertexCollection>                 vtx4DHandle_;
  edm::EDGetTokenT<reco::MuonCollection>              muonsToken_;
  edm::Handle<reco::MuonCollection>                   muonsHandle_;
  edm::EDGetTokenT<edm::View<reco::Track> >           tracksToken_;
  edm::Handle<edm::View<reco::Track> >                tracksHandle_;
  edm::EDGetTokenT<edm::ValueMap<float> >             timeToken_;
  edm::Handle<edm::ValueMap<float> >                  timeHandle_;
  edm::EDGetTokenT<edm::ValueMap<float> >             timeResToken_;
  edm::Handle<edm::ValueMap<float> >                  timeResHandle_;
  // edm::EDGetTokenT<std::vector<std::vector<float> > > ebtimeToken_;
  // edm::Handle<std::vector<std::vector<float> > >      ebtimeHandle_;    
  edm::EDGetTokenT<reco::GenParticleCollection>       genPartToken_;
  edm::Handle<reco::GenParticleCollection>            genPartHandle_;
  edm::EDGetTokenT<vector<reco::GenJet> >             genJetToken_;
  edm::Handle<vector<reco::GenJet> >                  genJetHandle_;

  //---
  vector<double> targetResolutions_;
  double dzCut_;


  //---I/O
  int iEvent_;
  edm::Service<TFileService> fs;
  map<double, FTLMuonIsoTree> outTrees_;

  //---options
  bool           useMCTruthPV_;
  vector<double> isoConeSizes_;
};

//
// constants, enums and typedefs
//

//
// static data member definitions
//

//
// constructors and destructor
//
FTLMuonIsolation::FTLMuonIsolation(const edm::ParameterSet& pSet) :
  genXYZToken_(consumes<genXYZ>(pSet.getUntrackedParameter<edm::InputTag>("genXYZTag"))),
  genT0Token_(consumes<float>(pSet.getUntrackedParameter<edm::InputTag>("genT0Tag"))),
  simVtxToken_(consumes<vector<SimVertex> >(pSet.getUntrackedParameter<edm::InputTag>("genVtxTag"))),
  vtx3DToken_(consumes<std::vector<reco::Vertex> >(pSet.getUntrackedParameter<edm::InputTag>("vtxTag3D"))),
  vtx4DToken_(consumes<std::vector<reco::Vertex> >(pSet.getUntrackedParameter<edm::InputTag>("vtxTag4D"))),
  muonsToken_(consumes<reco::MuonCollection>(pSet.getUntrackedParameter<edm::InputTag>("muonsTag"))),
  tracksToken_(consumes<edm::View<reco::Track> >(pSet.getUntrackedParameter<edm::InputTag>("tracksTag"))),
  timeToken_(consumes<edm::ValueMap<float> >(pSet.getUntrackedParameter<edm::InputTag>("timeTag"))),
  timeResToken_(consumes<edm::ValueMap<float> >(pSet.getUntrackedParameter<edm::InputTag>("timeResTag"))),
  genPartToken_(consumes<reco::GenParticleCollection>(pSet.getUntrackedParameter<edm::InputTag>("genPartTag"))),
  genJetToken_(consumes<std::vector<reco::GenJet> >(pSet.getUntrackedParameter<edm::InputTag>("genJetsTag"))),
  targetResolutions_(pSet.getUntrackedParameter<vector<double> >("targetResolutions")),
  dzCut_(pSet.getUntrackedParameter<double>("dzCut"))
{
  iEvent_ = 0;
  for (auto& res : targetResolutions_) outTrees_[res] = FTLMuonIsoTree(
    (pSet.getUntrackedParameter<string>("treeName")+"_"+to_string(int(res*1000))).c_str(),
    "Muon tree for FTL studies"
  );
  useMCTruthPV_ = pSet.getUntrackedParameter<bool>("useMCTruthPV");
  isoConeSizes_ = pSet.getUntrackedParameter<vector<double> >("isoConeSizes");
}

//
// member functions
//

// ------------ method called for each event  ------------
void FTLMuonIsolation::analyze(const edm::Event& iEvent, const edm::EventSetup& iSetup){
  //---get input collections
  iEvent.getByToken(genXYZToken_, genXYZHandle_);
  iEvent.getByToken(genT0Token_, genT0Handle_);
  iEvent.getByToken(muonsToken_, muonsHandle_);
  iEvent.getByToken(tracksToken_, tracksHandle_);
  iEvent.getByToken(timeToken_, timeHandle_);
  iEvent.getByToken(timeResToken_, timeResHandle_);
  iEvent.getByToken(simVtxToken_, simVtxHandle_);
  iEvent.getByToken(vtx4DToken_, vtx4DHandle_);
  iEvent.getByToken(vtx3DToken_, vtx3DHandle_);
  iEvent.getByToken(genPartToken_, genPartHandle_);
  iEvent.getByToken(genJetToken_, genJetHandle_);

  edm::ESHandle<TransientTrackBuilder> theTTBuilder;
  iSetup.get<TransientTrackRecord>().get("TransientTrackBuilder", theTTBuilder);

  //---skip bad events (checks on muons and MC-truth vtx)
  unsigned int nmuons = 0;
  for (const auto &muon : *muonsHandle_) if (muon.pt() > 5.) ++nmuons;

  // if(!nmuons || vtx4DHandle_->size()<2 || vtx3DHandle_->size()<2 ||
  //    simVtxHandle_.product()->size() == 0 || simVtxHandle_.product()->at(0).vertexId() != 0
  //     )
  //     return;
  ++iEvent_;

  //---get truth PV
  SimVertex simPV;
  if (simVtxHandle_.isValid()) simPV = simVtxHandle_.product()->at(0);
  else{
    auto xyz = genXYZHandle_.product();
    auto t = *genT0Handle_.product();
    auto v = math::XYZVectorD(xyz->x(), xyz->y(), xyz->z());
    simPV = SimVertex(v, t);
  }

  for (auto& iRes : targetResolutions_){
    // Smear the track times
    std::map<reco::TrackRef, float> track_times;
    std::map<reco::TrackRef, float> track_timeResos;
    std::map<reco::TrackRef, float> track_t0;
    std::map<reco::TrackRef, float> track_t0err;
    for (unsigned i = 0; i < tracksHandle_->size(); ++i){
      auto ref = tracksHandle_->refAt(i);
      float time = (*timeHandle_)[ref];
      float timeReso = (*timeResHandle_)[ref] != 0.f ? (*timeResHandle_)[ref] : 0.170f;
      float extra_smearing = std::sqrt(iRes*iRes - timeReso*timeReso);
#if _useTrackTime_ == 0
      float t0 = time;
      float t0err = timeReso;
#else
      float t0 = ref->t0();
      float t0err = ref->t0Error();
#endif
      // cout << "Track " << i << ":\n";
      // cout << "              iRes: " << iRes << endl;
      // cout << "    extra_smearing: " << extra_smearing << endl;
      // cout << "     orig timeReso: " << timeReso << endl;
      // cout << "         orig time: " << time << endl;
      float timeextra = gRandom->Gaus(0., extra_smearing);
      time += timeextra;
      timeReso = std::sqrt(timeReso*timeReso + extra_smearing*extra_smearing);
      if (t0err>0.){
        t0 += timeextra;
        t0err = sqrt(pow(t0err, 2)+pow(extra_smearing, 2));
      }
      // cout << "          new time: " << time << endl;
      // cout << "      new timeReso: " << timeReso << endl;
      track_times[ref.castTo<reco::TrackRef>()] = time;
      track_timeResos[ref.castTo<reco::TrackRef>()] = timeReso;
      track_t0[ref.castTo<reco::TrackRef>()] = t0;
      track_t0err[ref.castTo<reco::TrackRef>()] = t0err;
    }

    // Determine vertex - track associations
    std::vector<std::vector<reco::TrackRef>> vertices_to_tracks_3D; vertices_to_tracks_3D.assign(vtx3DHandle_->size(), std::vector<reco::TrackRef>());
    std::vector<std::vector<reco::TrackRef>> vertices_to_tracks_4D; vertices_to_tracks_4D.assign(vtx4DHandle_->size(), std::vector<reco::TrackRef>());

    for (unsigned int itrk=0; itrk<tracksHandle_->size(); itrk++){
      auto ref = tracksHandle_->refAt(itrk);
      reco::TransientTrack ttrk = theTTBuilder->build(*ref);

      // Loop over 3D vertices
      int chosenVtx3D=-1;
      for (unsigned int ivtx=0; ivtx<vtx3DHandle_->size(); ivtx++){
        const auto& vtx = vtx3DHandle_->at(ivtx);
        if (!vtx.isValid() || vtx.isFake()) continue;
        const float weight = vtx.trackWeight(ref);
        if (weight>0.) chosenVtx3D = ivtx;
      }
      if(chosenVtx3D<0){
        float minSIP=std::numeric_limits<float>::max();
        for (unsigned int ivtx=0; ivtx<vtx3DHandle_->size(); ivtx++){
          const auto& vtx = vtx3DHandle_->at(ivtx);
          if (!vtx.isValid() || vtx.isFake()) continue;
          std::pair<bool, Measurement1D> IP_Measurement = IPTools::signedImpactParameter3D(
            ttrk,
            GlobalVector(ref->px(), ref->py(), ref->pz()),
            vtx
          );
          float IP_Vtx = IP_Measurement.second.value();
          float dIP_Vtx = IP_Measurement.second.error();
          const float valSIP = (dIP_Vtx!=0. ? fabs(IP_Vtx)/dIP_Vtx : 0);
          if (minSIP>valSIP){
            minSIP = valSIP;
            chosenVtx3D = ivtx;
          }
        }
      }
      if (chosenVtx3D<0) chosenVtx3D=0;
      vertices_to_tracks_3D.at(chosenVtx3D).push_back(ref.castTo<reco::TrackRef>());

      // Loop over 4D vertices
      int chosenVtx4D=-1;
      for (unsigned int ivtx=0; ivtx<vtx4DHandle_->size(); ivtx++){
        const auto& vtx = vtx4DHandle_->at(ivtx);
        if (!vtx.isValid() || vtx.isFake()) continue;
        const float weight = vtx.trackWeight(ref);
        if (weight>0.) chosenVtx4D = ivtx;
      }
      if (chosenVtx4D<0){
        float minSIP=std::numeric_limits<float>::max();
        bool trackhastime = (track_t0err[ref.castTo<reco::TrackRef>()]>0.);
        if (trackhastime){ // Search within vertices with time measurement first if the track has time. Include dt/delta_dt in SIP
          for (unsigned int ivtx=0; ivtx<vtx4DHandle_->size(); ivtx++){
            const auto& vtx = vtx4DHandle_->at(ivtx);
            if (!vtx.isValid() || vtx.isFake()) continue;
            std::pair<bool, Measurement1D> IP_Measurement = IPTools::signedImpactParameter3D(
              ttrk,
              GlobalVector(ref->px(), ref->py(), ref->pz()),
              vtx
            );
            float IP_Vtx = IP_Measurement.second.value();
            float dIP_Vtx = IP_Measurement.second.error();
            IP_Vtx *= fabs(vtx.t()-track_t0[ref.castTo<reco::TrackRef>()]);
            dIP_Vtx *= sqrt(pow(track_t0err[ref.castTo<reco::TrackRef>()], 2) + pow(vtx.tError(), 2));
            const float valSIP = (dIP_Vtx!=0. ? fabs(IP_Vtx)/dIP_Vtx : 0);
            if (minSIP>valSIP){
              minSIP = valSIP;
              chosenVtx4D = ivtx;
            }
          }
        }
        minSIP=std::numeric_limits<float>::max();
        for (unsigned int ivtx=0; ivtx<vtx4DHandle_->size(); ivtx++){
          const auto& vtx = vtx4DHandle_->at(ivtx);
          if (!vtx.isValid() || vtx.isFake()) continue;
          std::pair<bool, Measurement1D> IP_Measurement = IPTools::signedImpactParameter3D(
            ttrk,
            GlobalVector(ref->px(), ref->py(), ref->pz()),
            vtx
          );
          float IP_Vtx = IP_Measurement.second.value();
          float dIP_Vtx = IP_Measurement.second.error();
          const float valSIP = (dIP_Vtx!=0. ? fabs(IP_Vtx)/dIP_Vtx : 0);
          if (minSIP>valSIP){
            minSIP = valSIP;
            chosenVtx4D = ivtx;
          }
        }
      }
      if (chosenVtx4D<0) chosenVtx4D=0;
      vertices_to_tracks_4D.at(chosenVtx4D).push_back(ref.castTo<reco::TrackRef>());
    }

    // Loop over the muons
    for (auto &muon : *muonsHandle_){
      //---reset output
      outTrees_[iRes].Reset();

      //---fill global info            
      outTrees_[iRes].event = iEvent.id().event();
      outTrees_[iRes].lumi = iEvent.id().luminosityBlock();
      outTrees_[iRes].run = iEvent.id().run();

      //---basic check
      if (muon.track().isNull() || muon.pt() < 10) continue;

      auto muontrack = muon.track();
      auto muontrackref = muon.get<reco::TrackRef>();
      reco::TransientTrack ttmuon = theTTBuilder->build(muontrackref);

      bool hasLinkedVtx3D=false;
      bool hasLinkedVtx4D=false;

      int vtx3D_index = -1;
      float ip3DVtx3D=-1, d_ip3DVtx3D=-1;

      //---find the 3D vertex this muon is best associated to..
      if (useMCTruthPV_){
        float min_dz = 999.;
        for (unsigned i = 0; i < vtx3DHandle_->size(); ++i){
          const auto& vtx = (*vtx3DHandle_)[i];
          const float dz = fabs(vtx.z() - simPV.position().z());
          if (dz < min_dz){
            min_dz = dz;
            vtx3D_index = i;
          }
        }
      }
      else{
        float max_weight3D = 0.f;
        for (unsigned i = 0; i < vtx3DHandle_->size(); ++i){
          const auto& vtx = (*vtx3DHandle_)[i];
          const float weight = vtx.trackWeight(muon.track());
          if (weight > max_weight3D){
            max_weight3D = weight;
            vtx3D_index = i;
            hasLinkedVtx3D=true;
          }
        }
        if (vtx3D_index==-1){
          float minSIP=std::numeric_limits<float>::max();
          for (unsigned i = 0; i < vtx3DHandle_->size(); ++i){
            const auto& vtx = (*vtx3DHandle_)[i];
            if (!vtx.isValid() || vtx.isFake()) continue;
            std::pair<bool, Measurement1D> IP_Measurement = IPTools::signedImpactParameter3D(
              ttmuon,
              GlobalVector(muon.px(), muon.py(), muon.pz()),
              vtx
            );
            float IP_Vtx = IP_Measurement.second.value();
            float dIP_Vtx = IP_Measurement.second.error();
            const float valSIP = (dIP_Vtx!=0. ? fabs(IP_Vtx)/dIP_Vtx : 0);
            if (minSIP>valSIP){
              minSIP = valSIP;
              vtx3D_index = i;
            }
          }
        }
      }
      if (vtx3D_index<0) vtx3D_index=0;
      const reco::Vertex& vtx3D = vtx3DHandle_->at(vtx3D_index);
      {
        std::pair<bool, Measurement1D> IP_Measurement = IPTools::signedImpactParameter3D(
          ttmuon,
          GlobalVector(muon.px(), muon.py(), muon.pz()),
          vtx3D
        );
        float IP_Vtx = IP_Measurement.second.value();
        float dIP_Vtx = IP_Measurement.second.error();
        ip3DVtx3D=IP_Vtx;
        d_ip3DVtx3D=dIP_Vtx;
      }

      int vtx4D_index = -1;
      float ip3DVtx4D=-1, d_ip3DVtx4D=-1;

      //---find the 4D vertex this muon is best associated to..
      if (useMCTruthPV_){
        double min_dzdt = std::numeric_limits<double>::max();
        for (unsigned i = 0; i < vtx4DHandle_->size(); ++i){
          const auto& vtx = (*vtx4DHandle_)[i];
          const float dz = std::abs(vtx.z() - simPV.position().z());
          const double dzdt = pow((vtx.z() - simPV.position().z())/vtx.zError(), 2) +
            pow((vtx.t()-simPV.position().t())/vtx.tError(), 2);
          if (dz < 0.1 && dzdt < min_dzdt){
            min_dzdt = dzdt;
            vtx4D_index = i;
          }
        }
      }
      else{
        float max_weight4D = 0.f;
        for (unsigned i = 0; i < vtx4DHandle_->size(); ++i){
          const auto& vtx = (*vtx4DHandle_)[i];
          const float weight = vtx.trackWeight(muon.track());
          if (weight > max_weight4D){
            max_weight4D = weight;
            vtx4D_index = i;
            hasLinkedVtx4D=true;
          }
        }
        if (vtx4D_index==-1){
          bool trackhastime = (track_t0err[muontrackref]>0.);
          float minSIP=std::numeric_limits<float>::max();
          if (trackhastime){ // Search within vertices with time measurement first if the muon track has time. Include dt/delta_dt in SIP
            for (unsigned i = 0; i < vtx4DHandle_->size(); ++i){
              const auto& vtx = (*vtx4DHandle_)[i];
              if (!vtx.isValid() || vtx.isFake()) continue;
              if (vtx.tError()==0.) continue;
              std::pair<bool, Measurement1D> IP_Measurement = IPTools::signedImpactParameter3D(
                ttmuon,
                GlobalVector(muon.px(), muon.py(), muon.pz()),
                vtx
              );
              float IP_Vtx = IP_Measurement.second.value();
              float dIP_Vtx = IP_Measurement.second.error();
              IP_Vtx *= fabs(vtx.t()-track_t0[muontrackref]);
              dIP_Vtx *= sqrt(pow(track_t0err[muontrackref], 2) + pow(vtx.tError(), 2));
              const float valSIP = (dIP_Vtx!=0. ? fabs(IP_Vtx)/dIP_Vtx : 0);
              if (minSIP>valSIP){
                minSIP = valSIP;
                vtx4D_index = i;
              }
            }
          }
          // If track-vertex association still cannot be made, revert to time-less SIP over all 4D vertices
          minSIP=std::numeric_limits<float>::max();
          for (unsigned i = 0; i < vtx4DHandle_->size(); ++i){
            const auto& vtx = (*vtx4DHandle_)[i];
            if (!vtx.isValid() || vtx.isFake()) continue;
            std::pair<bool, Measurement1D> IP_Measurement = IPTools::signedImpactParameter3D(
              ttmuon,
              GlobalVector(muon.px(), muon.py(), muon.pz()),
              vtx
            );
            float IP_Vtx = IP_Measurement.second.value();
            float dIP_Vtx = IP_Measurement.second.error();
            const float valSIP = (dIP_Vtx!=0. ? fabs(IP_Vtx)/dIP_Vtx : 0);
            if (minSIP>valSIP){
              minSIP = valSIP;
              vtx4D_index = i;
            }
          }
        }
      }
      if (vtx4D_index<0) vtx4D_index=0;
      const reco::Vertex& vtx4D = vtx4DHandle_->at(vtx4D_index);
      {
        std::pair<bool, Measurement1D> IP_Measurement = IPTools::signedImpactParameter3D(
          ttmuon,
          GlobalVector(muon.px(), muon.py(), muon.pz()),
          vtx4D
        );
        float IP_Vtx = IP_Measurement.second.value();
        float dIP_Vtx = IP_Measurement.second.error();
        ip3DVtx4D=IP_Vtx;
        d_ip3DVtx4D=dIP_Vtx;
      }

      //---muon - vtx matching
      float muonTime = (*timeHandle_)[muontrack];
      float muonTimeReso = (*timeResHandle_)[muontrack];
      if (useMCTruthPV_ && (muonTimeReso==0 ||
        (muon.track()->dz(Point(simPV.position().x(),
                                simPV.position().y(),
                                simPV.position().z())) > 0.1 &&
         std::abs(simPV.position().t()-muonTime) > 3*muonTimeReso)))
        continue;

      //---event counter
      outTrees_[iRes].iEvent = iEvent_;

      //---fill gen vtx info
      outTrees_[iRes].simPVX = simPV.position().x();
      outTrees_[iRes].simPVY = simPV.position().y();
      outTrees_[iRes].simPVZ = simPV.position().z();
      outTrees_[iRes].simPVT = simPV.position().t();

      //---fill muon and vtx information            
      outTrees_[iRes].pt = muon.pt();
      outTrees_[iRes].eta = muon.eta();
      outTrees_[iRes].phi = muon.phi();
      outTrees_[iRes].px = muon.px();
      outTrees_[iRes].py = muon.py();
      outTrees_[iRes].pz = muon.pz();
      outTrees_[iRes].vx = muon.track()->vx();
      outTrees_[iRes].vy = muon.track()->vy();
      outTrees_[iRes].vz = muon.track()->vz();
      outTrees_[iRes].t0 = track_t0[muontrackref];
      outTrees_[iRes].t0err = track_t0err[muontrackref];
      outTrees_[iRes].muonT = track_times[muontrackref];
      outTrees_[iRes].muonTreso = track_timeResos[muontrackref];
      outTrees_[iRes].isLooseMuon = muon::isLooseMuon(muon);
      outTrees_[iRes].isMediumMuon = muon::isMediumMuon(muon);
      outTrees_[iRes].isTightMuon = muon::isTightMuon(muon, (*vtx4DHandle_)[vtx4D_index==-1 ? 0 : vtx4D_index]);
      outTrees_[iRes].nVtx3D = vtx3DHandle_->size();
      outTrees_[iRes].nVtx4D = vtx4DHandle_->size();
      outTrees_[iRes].hasLinkedVtx3D=hasLinkedVtx3D;
      outTrees_[iRes].hasLinkedVtx4D=hasLinkedVtx4D;
      outTrees_[iRes].vtx3DIdx = vtx3D_index;
      outTrees_[iRes].vtx4DIdx = vtx4D_index;
      outTrees_[iRes].vtx3DX = vtx3D.x();
      outTrees_[iRes].vtx3DY = vtx3D.y();
      outTrees_[iRes].vtx3DZ = vtx3D.z();
      outTrees_[iRes].IP3DVtx3D = ip3DVtx3D;
      outTrees_[iRes].dIP3DVtx3D = d_ip3DVtx3D;
      outTrees_[iRes].vtx3DIsFake = vtx3D.isFake();
      outTrees_[iRes].vtx3DNdof = vtx3D.ndof();
      outTrees_[iRes].vtx3DChi2 = vtx3D.chi2();
      outTrees_[iRes].nTracksVtx3D = vtx3D.nTracks(0.);
      //outTrees_[iRes].vtx3DT = vtx3D.t();
      outTrees_[iRes].vtx4DX = vtx4D.x();
      outTrees_[iRes].vtx4DY = vtx4D.y();
      outTrees_[iRes].vtx4DZ = vtx4D.z();
      outTrees_[iRes].vtx4DT = vtx4D.t();
      outTrees_[iRes].vtx4DTerr = vtx4D.tError();
      outTrees_[iRes].IP3DVtx4D = ip3DVtx4D;
      outTrees_[iRes].dIP3DVtx4D = d_ip3DVtx4D;
      outTrees_[iRes].vtx4DIsFake = vtx4D.isFake();
      outTrees_[iRes].vtx4DNdof = vtx4D.ndof();
      outTrees_[iRes].vtx4DChi2 = vtx4D.chi2();
      outTrees_[iRes].nTracksVtx4D = vtx4D.nTracks(0.);

      //---compute the varius isolations for all requested cone sizes
      outTrees_[iRes].nTracksZCut = 0;
      outTrees_[iRes].nTracksZTCut = 0;
      outTrees_[iRes].chIsoZCut->resize(isoConeSizes_.size());
      outTrees_[iRes].chIsoZTCut_3sigma->resize(isoConeSizes_.size());
      outTrees_[iRes].chIsoZTCut_4sigma->resize(isoConeSizes_.size());
      outTrees_[iRes].chIsoZTCut_5sigma->resize(isoConeSizes_.size());
      outTrees_[iRes].chIsoZTCut_7sigma->resize(isoConeSizes_.size());
      outTrees_[iRes].chIsoZTCut_10sigma->resize(isoConeSizes_.size());

      outTrees_[iRes].tracksZCut_pt->clear();
      outTrees_[iRes].tracksZCut_eta->clear();
      outTrees_[iRes].tracksZCut_phi->clear();
      outTrees_[iRes].tracksZCut_dR->clear();
      outTrees_[iRes].tracksZCut_t->clear();
      outTrees_[iRes].tracksZCut_dz->clear();
      outTrees_[iRes].tracksZTCut_pt->clear();
      outTrees_[iRes].tracksZTCut_eta->clear();
      outTrees_[iRes].tracksZTCut_phi->clear();
      outTrees_[iRes].tracksZTCut_dR->clear();
      outTrees_[iRes].tracksZTCut_t->clear();
      outTrees_[iRes].tracksZTCut_dz->clear();

      for (int iDR=0; iDR<(int) isoConeSizes_.size(); ++iDR){
        float const& DR = isoConeSizes_[iDR];
        outTrees_[iRes].chIsoDR->push_back(DR);

        outTrees_[iRes].chIsoZCut->at(iDR) = 0.0;
        outTrees_[iRes].chIsoZTCut_3sigma->at(iDR) = 0.0;
        outTrees_[iRes].chIsoZTCut_4sigma->at(iDR) = 0.0;
        outTrees_[iRes].chIsoZTCut_5sigma->at(iDR) = 0.0;
        outTrees_[iRes].chIsoZTCut_7sigma->at(iDR) = 0.0;
        outTrees_[iRes].chIsoZTCut_10sigma->at(iDR) = 0.0;

        // Compute charged trk isolation from the 3D vertex
        std::vector<reco::TrackRef>& tracks_3D = vertices_to_tracks_3D.at(vtx3D_index);
        for (auto& ref:tracks_3D){
          if (!ref->quality(reco::TrackBase::highPurity)) continue;

          const float dz = std::abs(ref->dz(vtx3D.position()));
          const bool keepz = (dz < dzCut_);
          const float this_dr = reco::deltaR2(ref->eta(), ref->phi(), muon.eta(), muon.phi());

          if (iDR==0){
            outTrees_[iRes].nTracksZCut += 1;
            outTrees_[iRes].tracksZCut_pt->push_back(ref->pt());
            outTrees_[iRes].tracksZCut_eta->push_back(ref->eta());
            outTrees_[iRes].tracksZCut_phi->push_back(ref->phi());
            outTrees_[iRes].tracksZCut_dR->push_back(this_dr);
            outTrees_[iRes].tracksZCut_t->push_back(track_times[ref]);
            outTrees_[iRes].tracksZCut_dz->push_back(ref->dz(vtx3D.position()));
          }

          if (ref==muontrack) continue;
          if (!keepz) continue;
          if (this_dr >= DR*DR) continue;
          outTrees_[iRes].chIsoZCut->at(iDR) += ref->pt();
        }

        // Compute charged trk isolation from the 4D vertex
        std::vector<reco::TrackRef>& tracks_4D = vertices_to_tracks_4D.at(vtx4D_index);
        for (auto& ref:tracks_4D){
          if (!ref->quality(reco::TrackBase::highPurity)) continue;

          const float dz = std::abs(ref->dz(vtx4D.position()));
          const bool keepz = (dz < dzCut_);
          const float this_dr = reco::deltaR2(ref->eta(), ref->phi(), muon.eta(), muon.phi());

          const float t0 = track_t0[ref];
          const float t0err = track_t0err[ref];
          const float dt = std::abs(t0 - vtx4D.t());
          const bool useTime = (vtx4D.tError()>0. && t0err>0.);
          const float base_cut = std::sqrt(vtx4D.tError()*vtx4D.tError() + t0err*t0err);
          const float time_cut3 = 3.f*base_cut;
          const float time_cut4 = 4.f*base_cut;
          const float time_cut5 = 5.f*base_cut;
          const float time_cut7 = 7.f*base_cut;
          const float time_cut10 = 10.f*base_cut;

          const bool keept3 = (!useTime || std::isnan(dt) || dt < time_cut3);
          const bool keept4 = (!useTime || std::isnan(dt) || dt < time_cut4);
          const bool keept5 = (!useTime || std::isnan(dt) || dt < time_cut5);
          const bool keept7 = (!useTime || std::isnan(dt) || dt < time_cut7);
          const bool keept10 = (!useTime || std::isnan(dt) || dt < time_cut10);

          if (iDR==0){
            outTrees_[iRes].nTracksZTCut += 1;
            outTrees_[iRes].tracksZTCut_pt->push_back(ref->pt());
            outTrees_[iRes].tracksZTCut_eta->push_back(ref->eta());
            outTrees_[iRes].tracksZTCut_phi->push_back(ref->phi());
            outTrees_[iRes].tracksZTCut_dR->push_back(this_dr);
            outTrees_[iRes].tracksZTCut_t->push_back(t0);
            outTrees_[iRes].tracksZTCut_dz->push_back(ref->dz(vtx4D.position()));
          }

          if (ref==muontrack) continue;
          if (!keepz) continue;
          if (this_dr >= DR*DR) continue;

          if (keept3)
            outTrees_[iRes].chIsoZTCut_3sigma->at(iDR) += ref->pt();
          if (keept4)
            outTrees_[iRes].chIsoZTCut_4sigma->at(iDR) += ref->pt();
          if (keept5)
            outTrees_[iRes].chIsoZTCut_5sigma->at(iDR) += ref->pt();
          if (keept7)
            outTrees_[iRes].chIsoZTCut_7sigma->at(iDR) += ref->pt();
          if (keept10)
            outTrees_[iRes].chIsoZTCut_10sigma->at(iDR) += ref->pt();
        }

      }

      //---Gen matching
      outTrees_[iRes].genMatched = false;
      outTrees_[iRes].genMatchedPrompt = false;
      outTrees_[iRes].genMatchedJet = false;
      outTrees_[iRes].genPt = -99.;
      outTrees_[iRes].genEta = -99.;
      outTrees_[iRes].genPhi = -99.;

      double mindr = std::numeric_limits<double>::max();

      reco::Vertex::Point matchedPartVtx;
      int globalMatchPartId=-99;
      for (const reco::GenParticle &p : *genPartHandle_){
        if (p.status() != 1) continue;

        double dr = reco::deltaR(muon, p);
        if (dr<mindr){
          mindr = dr;
          matchedPartVtx = p.vertex();
          globalMatchPartId = p.pdgId();
        }
      }
      outTrees_[iRes].globalMatchPartId = globalMatchPartId;
      outTrees_[iRes].globalMatchPartVtxX = matchedPartVtx.x();
      outTrees_[iRes].globalMatchPartVtxY = matchedPartVtx.y();
      outTrees_[iRes].globalMatchPartVtxZ = matchedPartVtx.z();

      mindr = std::numeric_limits<double>::max();
      for (const reco::GenParticle &p : *genPartHandle_){
        if (p.status() != 1) continue;
        if (std::abs(p.pdgId()) != 13) continue;

        double dr = reco::deltaR(muon, p);
        if (dr<0.2 && dr<mindr){
          mindr = dr;
          outTrees_[iRes].genMatched = true;
          outTrees_[iRes].genMatchedPrompt = p.isPromptFinalState();
          outTrees_[iRes].genPt = p.pt();
          outTrees_[iRes].genEta = p.eta();
          outTrees_[iRes].genPhi = p.phi();
        }
      }

      outTrees_[iRes].genJetE = -99.;
      outTrees_[iRes].genJetPt = -99.;
      outTrees_[iRes].genJetEta = -99.;
      outTrees_[iRes].genJetPhi = -99.;
      mindr = std::numeric_limits<double>::max();
      for (const auto& jet : *genJetHandle_){
        if (jet.pt() < 15.0 || jet.hadEnergy()/jet.energy() < 0.3)
          continue;
        double dr = reco::deltaR(muon, jet);
        if (dr < 0.3 && dr < mindr){
          mindr = dr;
          outTrees_[iRes].genMatchedJet = true;
          outTrees_[iRes].genJetE = jet.energy();
          outTrees_[iRes].genJetPt = jet.pt();
          outTrees_[iRes].genJetEta = jet.eta();
          outTrees_[iRes].genJetPhi = jet.phi();
        }
      }

      //---Fill tree
      outTrees_[iRes].GetTTreePtr()->Fill();
    }
  }
}
  
// ------------ method fills 'descriptions' with the allowed parameters for the module  ------------
void
FTLMuonIsolation::fillDescriptions(edm::ConfigurationDescriptions& descriptions) {
  //The following says we do not know what parameters are allowed so do no validation
  // Please change this to state exactly what you do use, even if it is no parameters
  edm::ParameterSetDescription desc;
  desc.setUnknown();
  descriptions.addDefault(desc);
}

//define this as a plug-in
DEFINE_FWK_MODULE(FTLMuonIsolation);

#endif
